<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MR オセロゲーム</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', 'Meiryo UI', Meiryo, Arial, sans-serif;
      overflow: hidden;
      background-color: #1a1a2e;
      color: #e6e6ff;
    }
    .ui-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      background: linear-gradient(135deg, rgba(26, 26, 46, 0.9), rgba(40, 40, 80, 0.8));
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    .title {
      font-size: 36px;
      margin-bottom: 40px;
      text-shadow: 0 0 10px rgba(100, 149, 237, 0.8);
      font-weight: bold;
      color: #fff;
    }
    #startButton {
      padding: 20px 40px;
      background: linear-gradient(135deg, #4b6cb7, #182848);
      color: white;
      font-size: 22px;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      margin-bottom: 25px;
    }
    #startButton:hover {
      background: linear-gradient(135deg, #5d7ec9, #253c6d);
      transform: translateY(-2px);
      box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
    }
    #info {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: #fff;
      font-size: 20px;
      z-index: 2;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }
    .instructions {
      max-width: 500px;
      background: rgba(30, 30, 60, 0.7);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
      font-size: 16px;
      line-height: 1.6;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(100, 149, 237, 0.3);
    }
    .instructions h3 {
      margin-top: 0;
      color: #8eb8ff;
    }
    .control-list {
      list-style: none;
      padding: 0;
      margin: 0;
      text-align: center;
    }
    .control-list li {
      margin-bottom: 10px;
      font-size: 16px;
    }
    
    /* 表風のデザイン */
    .control-table {
      width: 80%;
      margin: 0 auto;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      border-collapse: separate;
      border-spacing: 0;
      overflow: hidden;
    }
    .control-table td {
      padding: 12px 20px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 1.2em;
      white-space: nowrap;
    }
    .control-table tr {
      border-bottom: 1px solid rgba(100, 149, 237, 0.2);
    }
    .control-table tr:last-child {
      border-bottom: none;
    }
    .control-table td {
      padding: 12px 15px;
      text-align: left;
      font-size: 16px;
    }
    .control-table td:first-child {
      font-weight: bold;
      width: 40%;
      border-right: 1px solid rgba(100, 149, 237, 0.2);
      color: #8eb8ff;
    }
    .device-status {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 30px;
      font-size: 18px;
      color: #8eb8ff;
    }
    .device-status .icon {
      margin-right: 10px;
      font-size: 24px;
    }
    .loading-container {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(20, 20, 40, 0.9);
      z-index: 20;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    .loading-spinner {
      width: 80px;
      height: 80px;
      border: 8px solid rgba(100, 149, 237, 0.3);
      border-radius: 50%;
      border-top: 8px solid #4b6cb7;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    .loading-text {
      font-size: 24px;
      color: #fff;
      text-shadow: 0 0 10px rgba(100, 149, 237, 0.5);
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="info">MR オセロゲーム</div>
  
  <div class="ui-container" id="menuUI">
    <h1 class="title">MR オセロゲーム</h1>
    
    <div class="device-status">
      <span class="icon">・</span>
      <span id="device-message">VR機器を検出しています...</span>
    </div>
    
    <button id="startButton">MRモード開始</button>
    
    <!-- デスクトップモード用のボタンを追加 -->
    <button id="desktopButton" style="background: linear-gradient(135deg, #366873, #183048); margin-bottom: 25px;">ブラウザモード開始</button>
    
    <div class="instructions">
      <h3>操作方法</h3>
      <table class="control-table">
        <tr>
          <td>グリップ</td>
          <td>ボード位置<br>高さ調整</td>
        </tr>
        <tr>
          <td>トリガー</td>
          <td>駒を置く</td>
        </tr>
      </table>
    </div>
  </div>
  
  <div class="loading-container" id="loadingUI">
    <div class="loading-spinner"></div>
    <div class="loading-text">MRモードを起動中...</div>
    <p class="loading-info">表示されるまで少々お待ちください</p>
  </div>
  
  <canvas id="canvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // グローバル変数
    let scene, camera, renderer;
    let board;          // オセロ盤（グループ）
    let boardBase = null; // 盤のベースメッシュ（衝突判定用）
    let statusDisplay;  // ステータス表示
    let boardCursor;    // 盤面カーソル
    let difficultyMenu; // 難易度選択メニュー
    let pieces = [];    // 駒のリスト
    let boardState = []; // 8×8の盤状態（0:空, 1:黒, -1:白）
    let currentPlayer = 1; // 1: 黒（プレイヤー）、-1: 白（CPU）
    let isPlayerTurn = true;
    let xrSession = null, xrReferenceSpace = null, xrHitTestSource = null;
    let controllers = []; // コントローラー配列に変更
    let gameStarted = false;
    let difficultySelected = false;
    let playerWins = 0, cpuWins = 0, draws = 0, moveCount = 0;
    let difficultyLevel = 'medium'; // デフォルトは中級
    let gameResultMenu; // ゲーム結果メニュー
    let particles = []; // パーティクル効果用
    let fireworks = []; // 花火効果用
    let soundEnabled = true; // 音声有効フラグ
    let listener; // 音声リスナー
    let sounds = {}; // 音声オブジェクト格納用
    let welcomeParticles = []; // お出迎えパーティクル用
    let lastSelectTime = 0; // 最後にselectイベントが発生した時間を保持
    let isProcessingMove = false; // 駒を置く処理中かどうかのフラグ

    // 持ち駒ケース関連の変数
    let playerPieceCase; // プレイヤーの持ち駒ケース
    let cpuPieceCase;    // CPUの持ち駒ケース
    let playerRemainingPieces = 32; // プレイヤー残り駒 (最大32個)
    let cpuRemainingPieces = 32;    // CPU残り駒 (最大32個)
    const MAX_PIECES = 32;          // プレイヤーとCPUそれぞれの最大駒数
    let displayedPlayerPieces = []; // 表示中のプレイヤー持ち駒
    let displayedCpuPieces = [];    // 表示中のCPU持ち駒

    // グリップ操作用変数
    let isGripping = [false, false]; // 両方のコントローラーの状態を保持
    let controllerInitialPositions = [new THREE.Vector3(), new THREE.Vector3()];
    let boardInitialPosition = new THREE.Vector3();

    // ひっくり返るアニメーション情報を保持するための変数
    let flippingPieces = []; // アニメーション中の駒を管理する配列
    let droppingPieces = []; // 駒を落とすアニメーション用の配列を追加

    // 駒のフリップアニメーション関連の定数
    const FLIP_RISE_HEIGHT = 0.08; // 駒が浮き上がる高さを増加（より目立つように）
    const FLIP_DURATION = 45; // アニメーション全体の長さを延長（より滑らか）
    const FLIP_RISE_TIME = 15; // 上昇に要するフレーム数を増加
    const FLIP_FALL_TIME = 15; // 下降に要するフレーム数を増加
    const FLIP_ROTATE_TIME = 15; // 回転に要するフレーム数を増加（より滑らか）
    const DELTA_MULTIPLIER = 1.5; // フレームレート調整のための乗数

    // -------------------------------
    // 有効手のマーカーを管理する配列
    // -------------------------------
    let validMoveMarkers = [];

    // -------------------------------
    // 有効手のマーカーを作成する関数
    // -------------------------------
    function createValidMoveMarker(row, col) {
      const markerGroup = new THREE.Group();
      
      // シンプルな円形のマーカー
      const circleGeometry = new THREE.CircleGeometry(0.02, 16);
      const circleMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.0, // 最初は透明
        side: THREE.DoubleSide,
        depthWrite: false
      });
      const circle = new THREE.Mesh(circleGeometry, circleMaterial);
      circle.rotation.x = -Math.PI / 2;
      circle.renderOrder = 60;
      markerGroup.add(circle);
      
      // セル中央に配置
      const boardX = -0.25 + 0.03125 + (col * 0.0625);
      const boardZ = -0.25 + 0.03125 + (row * 0.0625);
      markerGroup.position.set(boardX, 0.035, boardZ);
      
      // アニメーション用のデータ
      markerGroup.userData = {
        animationPhase: 0,
        fadeInDone: false,
        maxOpacity: 0.4,
        minOpacity: 0.15
      };
      
      return markerGroup;
    }

    // -------------------------------
    // 有効手マーカーを表示・更新する関数
    // -------------------------------
    function showValidMoves(player) {
      // 既存のマーカーをクリア
      clearValidMoveMarkers();
      
      // プレイヤーターンでない場合はマーカーを表示しない
      if (!isPlayerTurn) return;
      
      // 全セルをチェックして有効手にマーカーを表示
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          if (isValidMove(row, col, player)) {
            const marker = createValidMoveMarker(row, col);
            board.add(marker);
            validMoveMarkers.push(marker);
          }
        }
      }
    }

    // -------------------------------
    // 有効手マーカーをクリアする関数
    // -------------------------------
    function clearValidMoveMarkers() {
      for (const marker of validMoveMarkers) {
        board.remove(marker);
      }
      validMoveMarkers = [];
    }

    // -------------------------------
    // 有効手マーカーのアニメーション更新関数
    // -------------------------------
    function updateValidMoveMarkers(deltaTime) {
      for (const marker of validMoveMarkers) {
        if (marker.userData) {
          // 位相を更新（非常にゆっくり）
          marker.userData.animationPhase += deltaTime * 0.8;
          
          const circle = marker.children[0];
          if (circle && circle.material) {
            if (!marker.userData.fadeInDone) {
              // フェードイン効果（じわっと点灯）
              circle.material.opacity += deltaTime * 0.05; // 非常にゆっくりフェードイン
              
              if (circle.material.opacity >= marker.userData.maxOpacity) {
                // フェードイン完了
                circle.material.opacity = marker.userData.maxOpacity;
                marker.userData.fadeInDone = true;
              }
            } else {
              // ゆっくり点滅（サイン波で緩やかに）
              const opacityRange = marker.userData.maxOpacity - marker.userData.minOpacity;
              const pulseValue = Math.sin(marker.userData.animationPhase * 0.1) * 0.5 + 0.5;
              circle.material.opacity = marker.userData.minOpacity + pulseValue * opacityRange;
            }
          }
        }
      }
    }

    // -------------------------------
    // 効果音の初期化（WebAudio APIで生成）
    // -------------------------------
    function initSounds() {
      // オーディオリスナーの作成
      listener = new THREE.AudioListener();
      camera.add(listener);
      
      // 各種効果音を生成
      createSimpleSound('placePlayer', 0.5, 'playerPlace'); // プレイヤーが駒を置く音
      createSimpleSound('placeCPU', 0.5, 'cpuPlace');    // CPUが駒を置く音
      createSimpleSound('start', 0.7, 'startup');        // ゲーム開始音
      createSimpleSound('win', 0.7, 'fanfare');          // 勝利音
      createSimpleSound('lose', 0.5, 'low');             // 敗北音
      createSimpleSound('flip', 0.45, 'click');          // 駒がひっくり返る音（音量を0.3から0.45に上げる）
      createSimpleSound('select', 0.4, 'click');         // メニュー選択音
    }

    // -------------------------------
    // デスクトップモードで開始
    // -------------------------------
    async function startDesktopMode() {
      try {
        // ローディング画面を表示
        const loadingUI = document.getElementById('loadingUI');
        if (loadingUI) {
          loadingUI.style.display = 'flex';
        }
        
        // メニューUIを非表示
        document.getElementById('menuUI').style.display = 'none';
        
        // Three.jsのレンダラーを設定（XRなしの通常のレンダラー）
        renderer.xr.enabled = false; // XRを無効化
        
        // カメラの位置を設定（デスクトップ表示用）
        camera.position.set(0, 1.5, 1.2);
        camera.lookAt(0, 0.5, 0);
        
        // 通常のアニメーションループを開始
        renderer.setAnimationLoop(renderDesktopFrame);
        
        // 音声の初期化
        initSounds();
        
        // BGMを再生するコード
        const audioLoader = new THREE.AudioLoader();
        const bgm = new THREE.Audio(listener);
        audioLoader.load('osero.mp3', function(buffer) {
          bgm.setBuffer(buffer);
          bgm.setLoop(true);
          bgm.setVolume(0.3);
          bgm.play();
        });
        
        // ローディング画面を非表示
        setTimeout(() => {
          if (loadingUI) loadingUI.style.display = 'none';
          
          // 難易度選択メニュー表示
          placeInitialEnvironment();
          
          // デスクトップモードのマウスコントロールを設定
          setupDesktopControls();
        }, 1500);
        
      } catch (error) {
        // エラー時にはローディング画面を非表示に
        const loadingUI = document.getElementById('loadingUI');
        if (loadingUI) loadingUI.style.display = 'none';
        
        console.error('デスクトップモード開始中にエラー:', error);
        alert('デスクトップモード開始中にエラーが発生しました: ' + error.message);
      }
    }

    // -------------------------------
    // デスクトップモード用レンダリングループ
    // -------------------------------
    function renderDesktopFrame(time) {
      const deltaTime = 1;
      
      // ステータス表示のアニメーション更新
      updateStatusDisplay(deltaTime);
      
      // 有効手マーカーのアニメーション更新
      updateValidMoveMarkers(deltaTime);
      
      // 駒のフリップアニメーションを更新
      updateFlippingPieces(deltaTime);
      
      // 駒を落とすアニメーションを更新
      updateDroppingPieces(deltaTime);
      
      // フェードインアニメーションの更新
      if (difficultyMenu && difficultyMenu.userData && difficultyMenu.userData.fadeIn) {
        const fadeProgress = difficultyMenu.userData.fadeProgress;
        const fadeSpeed = difficultyMenu.userData.fadeSpeed;
        
        if (fadeProgress < 1) {
          // フェードイン進行中
          difficultyMenu.userData.fadeProgress = Math.min(fadeProgress + fadeSpeed, 1);
          const opacity = easeOutCubic(difficultyMenu.userData.fadeProgress);
          
          // メニューの全要素の透明度を更新
          difficultyMenu.traverse(child => {
            if (child.material && child.material.transparent) {
              if (child.material.opacity !== undefined) {
                // コンポーネントタイプに基づいて目標の不透明度を設定
                let targetOpacity = 0.9; // デフォルト
                
                if (child.userData && child.userData.type === 'startButton') {
                  targetOpacity = 0.9;
                } else if (child === difficultyMenu.children[1]) { // フレーム
                  targetOpacity = 0.8;
                }
                
                child.material.opacity = opacity * targetOpacity;
              }
            }
          });
        }
      }
      
      // 盤面のフェードインアニメーション更新
      if (board && board.userData && board.userData.fadeIn) {
        const fadeProgress = board.userData.fadeProgress;
        const fadeSpeed = board.userData.fadeSpeed;
        const userData = board.userData;
        
        if (fadeProgress < 1) {
          // フェードイン進行中
          board.userData.fadeProgress = Math.min(fadeProgress + fadeSpeed, 1);
          const progress = easeOutCubic(board.userData.fadeProgress);
          
          // 透明度の更新
          board.traverse(child => {
            if (child.material && child.material.transparent) {
              if (child.material.opacity !== undefined) {
                child.material.opacity = progress;
              }
            }
          });
          
          // 位置の更新（上から降りてくる）
          const currentY = userData.initialY + (userData.targetY - userData.initialY) * progress;
          board.position.y = currentY;
          
          // 回転アニメーション
          userData.rotationProgress += fadeSpeed * 2;
          const rotationAmount = (1 - progress) * Math.PI * 0.1; // 最大10度まで傾く
          board.rotation.x = Math.sin(userData.rotationProgress) * rotationAmount;
          
          // 光るエフェクト
          userData.glowIntensity += 0.05 * userData.glowDirection;
          if (userData.glowIntensity >= 1) {
            userData.glowDirection = -1;
          } else if (userData.glowIntensity <= 0) {
            userData.glowDirection = 1;
          }
          
          // 光るエフェクトの適用
          board.traverse(child => {
            if (child.material) {
              if (child.material.emissive) {
                const baseColor = child.material.color;
                child.material.emissive.setRGB(
                  baseColor.r * userData.glowIntensity * 0.3,
                  baseColor.g * userData.glowIntensity * 0.3,
                  baseColor.b * userData.glowIntensity * 0.3
                );
              }
            }
          });
        } else {
          // アニメーション完了時の処理
          board.rotation.x = 0; // 回転をリセット
          board.position.y = userData.targetY; // 位置を確実に目標位置に
          
          // 光るエフェクトをリセット
          board.traverse(child => {
            if (child.material && child.material.emissive) {
              child.material.emissive.setRGB(0, 0, 0);
            }
          });
          
          board.userData.fadeIn = false;
        }
      }
      
      // パーティクルシステムの更新
      updateParticles(deltaTime);
      
      // デスクトップモード用のカーソル処理
      updateDesktopCursor();
      
      // 描画
      renderer.render(scene, camera);
    }

    // -------------------------------
    // デスクトップモード用のマウス操作設定
    // -------------------------------
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let isMouseDown = false;

    function setupDesktopControls() {
      const canvas = document.getElementById('canvas');
      
      // マウス移動のイベントリスナー
      canvas.addEventListener('mousemove', function(event) {
        // マウス位置を正規化 (-1 から 1 の範囲)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });
      
      // クリックのイベントリスナー
      canvas.addEventListener('mousedown', function(event) {
        isMouseDown = true;
        handleDesktopClick();
      });
      
      canvas.addEventListener('mouseup', function() {
        isMouseDown = false;
      });
      
      // ウィンドウリサイズ時の対応
      window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // -------------------------------
    // デスクトップモード用のマウスカーソル処理
    // -------------------------------
    function updateDesktopCursor() {
      // プレイヤーターンでない場合は処理しない
      if (!gameStarted || !isPlayerTurn || !board || !boardBase) return;
      
      // レイキャストで交差を確認
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(boardBase);
      
      let cursorVisible = false;
      
      if (intersects.length > 0) {
        const intersect = intersects[0];
        const localPoint = board.worldToLocal(intersect.point.clone());
        
        let col = Math.floor((localPoint.x + 0.25) / 0.0625);
        let row = Math.floor((localPoint.z + 0.25) / 0.0625);
        
        if (col >= 0 && col < 8 && row >= 0 && row < 8) {
          const cellCenterX = -0.25 + 0.03125 + (col * 0.0625);
          const cellCenterZ = -0.25 + 0.03125 + (row * 0.0625);
          
          // カーソル表示を更新
          if (boardCursor) {
            boardCursor.visible = true;
            cursorVisible = true;
            boardCursor.position.set(cellCenterX, 0.032, cellCenterZ);
            
            // カーソル色：有効なら緑、無効なら赤
            const isValid = isValidMove(row, col, 1);
            const cursorColor = isValid ? 0x00ff00 : 0xff0000;
            
            boardCursor.traverse(child => {
              if (child instanceof THREE.Mesh && child.material.color) {
                child.material.color.setHex(cursorColor);
              } else if (child instanceof THREE.LineSegments && child.material.color) {
                child.material.color.setHex(cursorColor);
              } else if (child instanceof THREE.Points && child.material.color) {
                child.material.color.setHex(cursorColor);
              }
            });
          }
        }
      }
      
      // 盤面上にカーソルがない場合は非表示
      if (!cursorVisible && boardCursor) {
        boardCursor.visible = false;
      }
    }

    // -------------------------------
    // デスクトップモード用のクリック処理
    // -------------------------------
    function handleDesktopClick() {
      // プレイヤーターンでない場合は処理しない
      if (!gameStarted || !isPlayerTurn || !board || !boardBase) return;
      
      raycaster.setFromCamera(mouse, camera);
      
      // 難易度選択メニューの処理
      if (!difficultySelected && difficultyMenu) {
        // メニューの子要素を検索
        const menuIntersects = raycaster.intersectObject(difficultyMenu, true);
        
        if (menuIntersects.length > 0) {
          // クリックしたボタンを見つける
          const clickedButton = findButton(menuIntersects[0].object);
          if (clickedButton) {
            // 難易度ボタンがクリックされた場合
            if (clickedButton.userData.type === 'difficultyButton') {
              highlightButton(clickedButton);
            }
            // スタートボタンがクリックされた場合
            else if (clickedButton.userData.type === 'startButton') {
              handleStartButtonClick();
            }
          }
          return;
        }
      }
      
      // ゲーム結果メニューの処理
      if (gameResultMenu) {
        const resultIntersects = raycaster.intersectObject(gameResultMenu, true);
        
        if (resultIntersects.length > 0) {
          const clickedButton = findButton(resultIntersects[0].object);
          if (clickedButton) {
            if (clickedButton.userData.type === 'difficultyMenuButton') {
              // 難易度選択に戻るボタン
              handleDifficultyMenuButtonClick();
            } else if (clickedButton.userData.type === 'rematchButton') {
              // 同じ難易度で再戦ボタン
              handleRematchButtonClick(clickedButton.userData.playerWon);
            }
          }
          return;
        }
      }
      
      // 盤面のクリック処理
      const boardIntersects = raycaster.intersectObject(boardBase);
      
      if (boardIntersects.length > 0) {
        const intersect = boardIntersects[0];
        const localPoint = board.worldToLocal(intersect.point.clone());
        
        let col = Math.floor((localPoint.x + 0.25) / 0.0625);
        let row = Math.floor((localPoint.z + 0.25) / 0.0625);
        
        if (col >= 0 && col < 8 && row >= 0 && row < 8) {
          handlePlacePiece(row, col);
        }
      }
    }

    // -------------------------------
    // 駒を置く処理（共通処理）
    // -------------------------------
    function handlePlacePiece(row, col) {
      // ゲームが開始されていない、もしくはプレイヤーのターンでない場合は処理しない
      if (!gameStarted || !isPlayerTurn || isProcessingMove) return;
      
      // 有効な手かどうか確認
      if (isValidMove(row, col, currentPlayer)) {
        isProcessingMove = true;
        
        // 駒を置く音を再生
        playSound('placePlayer');
        
        // 実際に駒を配置
        placePiece(row, col, currentPlayer);
        
        // フリップする駒のアニメーションを開始
        const flippedPieces = getFlippablePieces(row, col, currentPlayer);
        for (const [r, c] of flippedPieces) {
          flipPiece(r, c);
        }
        
        // ターン終了時の処理をスケジュール
        setTimeout(() => {
          completePlayerTurn();
        }, 800);
      }
    }

    // -------------------------------
    // イベントリスナー設定とゲーム初期化
    // -------------------------------
    document.addEventListener('DOMContentLoaded', function() {
      init();
      
      document.getElementById('startButton').addEventListener('click', startXRSession);
      // デスクトップモード用のボタンにイベントリスナーを追加
      document.getElementById('desktopButton').addEventListener('click', startDesktopMode);
      
      // ページ読み込み時にVR機器のサポート状況をチェック
      checkVRSupport();
    });
      
      // プレイエリア（緑の部分）- より光沢のあるマテリアルに変更
      const boardGeometry = new THREE.BoxGeometry(0.5, 0.02, 0.5);
      const playAreaMaterial = new THREE.MeshPhysicalMaterial({ 
        color: 0x006400,
        roughness: 0.5,
        metalness: 0.35, // 0.3から0.35に変更して反射を強化
        reflectivity: 0.5, // 0.4から0.5に上げて反射を強化
        clearcoat: 0.3, // 0.2から0.3に上げて光沢を強化
        clearcoatRoughness: 0.2, // 0.3から0.2に下げてよりつややかに
        envMapIntensity: 0.7 // 環境マップの反射強度を上げる
      });
      boardBase = new THREE.Mesh(boardGeometry, playAreaMaterial);
      boardBase.position.y = 0.02;
      boardBase.name = 'boardBase';
      // 影の設定を追加
      boardBase.castShadow = true;
      boardBase.receiveShadow = true;
      boardGroup.add(boardBase);
      
      // グリッドライン（より精細でエレガントな線）
      const gridMaterial = new THREE.LineBasicMaterial({ 
        color: 0x000000,
        linewidth: 2,
        transparent: true,
        opacity: 0.7
      });
      
      for (let i = 0; i <= 8; i++) {
        const y = 0.031; // ボード表面より少し上
        const startX = -0.25 + (i * 0.0625);
        
        const points = [ 
          new THREE.Vector3(startX, y, -0.25), 
          new THREE.Vector3(startX, y, 0.25) 
        ];
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        boardGroup.add(new THREE.Line(geometry, gridMaterial));
      }
      
      for (let i = 0; i <= 8; i++) {
        const y = 0.031;
        const startZ = -0.25 + (i * 0.0625);
        
        const points = [ 
          new THREE.Vector3(-0.25, y, startZ), 
          new THREE.Vector3(0.25, y, startZ) 
        ];
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        boardGroup.add(new THREE.Line(geometry, gridMaterial));
      }
      
      // セルの点（交差点に小さな点）
      const dotGeometry = new THREE.SphereGeometry(0.004, 8, 8);
      const dotMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
      
      for (let i = 0; i <= 8; i++) {
        for (let j = 0; j <= 8; j++) {
          const dot = new THREE.Mesh(dotGeometry, dotMaterial);
          dot.position.set(-0.25 + (i * 0.0625), 0.032, -0.25 + (j * 0.0625));
          boardGroup.add(dot);
        }
      }
      
      // 和風装飾の追加（お茶碗を削除し、木の置物のみに）
      const decorationGroup = new THREE.Group();
      decorationGroup.position.y = 0.02; // 盤面と同じ高さ
      
      // 松の木（ミニチュア）- 反射効果を追加
      function createMiniPineTree() {
        const treeGroup = new THREE.Group();
        
        // 幹 - より光沢のあるマテリアルに変更
        const trunkGeometry = new THREE.CylinderGeometry(0.01, 0.02, 0.1, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x4a2f1c,
          roughness: 0.5,
          metalness: 0.2, // 反射効果を追加
          envMapIntensity: 0.3 // 環境マップの反射を追加
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        treeGroup.add(trunk);
        
        // 葉（円錐形）- より光沢のあるマテリアルに変更
        const leavesGeometry = new THREE.ConeGeometry(0.05, 0.15, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x2d5a27,
          roughness: 0.6,
          metalness: 0.15, // 反射効果を追加
          envMapIntensity: 0.25 // 環境マップの反射を追加
        });
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 0.1;
        treeGroup.add(leaves);
        
        // 木の根元に草を追加
        const grass = createGrass();
        grass.position.y = -0.05; // 根元に配置（y=0は幹の中心なので、-0.05で根元になる）
        treeGroup.add(grass);
        
        return treeGroup;
      }
      
      // 草
      function createGrass() {
        const grassGroup = new THREE.Group();
        const grassCount = 10;
        
        for (let i = 0; i < grassCount; i++) {
          const grassGeometry = new THREE.CylinderGeometry(0.001, 0.001, 0.05, 4);
          const grassMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d5a27,
            roughness: 0.7,
            metalness: 0.1, // 反射効果を追加
            envMapIntensity: 0.2 // 環境マップの反射を追加
          });
          const grass = new THREE.Mesh(grassGeometry, grassMaterial);
          
          // 根元周辺にランダムに配置
          grass.position.x = (Math.random() - 0.5) * 0.04; // 範囲を狭く
          grass.position.z = (Math.random() - 0.5) * 0.04; // 範囲を狭く
          grass.rotation.x = Math.random() * Math.PI * 2;
          grass.rotation.z = Math.random() * Math.PI * 2;
          
          grassGroup.add(grass);
        }
        
        return grassGroup;
      }
      
      // 装飾の配置（お茶碗は削除）
      const decorations = [
        { create: createMiniPineTree, position: new THREE.Vector3(-0.32, 0, -0.32) },
        { create: createMiniPineTree, position: new THREE.Vector3(0.32, 0, -0.32) },
        { create: createMiniPineTree, position: new THREE.Vector3(0.32, 0, 0.32) }, // 右下にも松の木を追加
        { create: createMiniPineTree, position: new THREE.Vector3(-0.32, 0, 0.32) }  // 左下にも松の木を追加
      ];
      
      // 装飾の追加（草は木の根元に追加済みなので別途追加しない）
      decorations.forEach(decoration => {
        const obj = decoration.create();
        obj.position.copy(decoration.position);
        // 装飾オブジェクトに影を設定
        obj.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        decorationGroup.add(obj);
      });
      
      boardGroup.add(decorationGroup);
      
      return boardGroup;
    }

    // -------------------------------
    // 洗練された盤面カーソル
    // -------------------------------
    function createBoardCursor() {
      const cursorGroup = new THREE.Group();
      
      // 半透明の平面（セル全体）
      const planeGeometry = new THREE.PlaneGeometry(0.0625, 0.0625);
      const planeMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffaa,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.rotation.x = -Math.PI / 2; // 盤面に合わせて水平に
      cursorGroup.add(plane);
      
      // 枠線（エッジをハイライト）
      const edgeGeometry = new THREE.EdgesGeometry(planeGeometry);
      const edgeMaterial = new THREE.LineBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 0.8,
        linewidth: 2
      });
      const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
      edges.rotation.x = -Math.PI / 2;
      cursorGroup.add(edges);
      
      // 角の装飾（小さな球体）
      const sphereGeometry = new THREE.SphereGeometry(0.003, 8, 8);
      const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      
      // 四隅に小さな球体を配置
      const cornerPositions = [
        [-0.03125, 0, -0.03125],
        [ 0.03125, 0, -0.03125],
        [-0.03125, 0,  0.03125],
        [ 0.03125, 0,  0.03125]
      ];
      
      cornerPositions.forEach(pos => {
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(pos[0], 0.001, pos[2]);
        cursorGroup.add(sphere);
      });
      
      cursorGroup.visible = false;
      return cursorGroup;
    }

    // -------------------------------
    // 高級感のある駒の作成
    // -------------------------------
    function createPiece(x, z, player) {
      const radius = 0.028; // 半径を0.03から0.028に縮小
      const height = 0.004; // 高さも0.005から0.004に調整
      const segments = 32;
      const radiusSegments = 32; // 円周の分割数
      const edgeRadius = 0.0025; // エッジの丸み
      
      // 高級感のある駒のジオメトリ（エッジを丸くする）
      const geometry = new THREE.CylinderGeometry(radius, radius, height, segments, 1, false, 0, Math.PI * 2);
      
      // エッジを滑らかにする
      geometry.vertices = bevelCylinderEdges(geometry.vertices, radius, height, edgeRadius);
      
      let material;
      if (player === 1) {
        // 黒駒（艶のある黒檀風）
        material = new THREE.MeshPhysicalMaterial({
          color: 0x111111,
          metalness: 0.15,  // 0.1から0.15に変更
          roughness: 0.15,  // 0.2から0.15に変更でより艶やかに
          reflectivity: 0.6, // 0.5から0.6に変更
          clearcoat: 0.4,    // 0.3から0.4に変更
          clearcoatRoughness: 0.15 // 0.2から0.15に変更
        });
      } else {
        // 白駒（大理石風）
        material = new THREE.MeshPhysicalMaterial({
          color: 0xf5f5f5,  // より純白に
          metalness: 0.12,  // 0.1から0.12に変更
          roughness: 0.25,  // 0.3から0.25に変更
          reflectivity: 0.8, // 0.7から0.8に変更
          clearcoat: 0.6,    // 0.5から0.6に変更
          clearcoatRoughness: 0.08 // 0.1から0.08に変更
        });
      }
      
      const piece = new THREE.Mesh(geometry, material);
      
      // セル中央に配置：左下(-0.25,-0.25)から各セル0.0625、中央は+0.03125
      const boardX = -0.25 + 0.03125 + (x * 0.0625);
      const boardZ = -0.25 + 0.03125 + (z * 0.0625);
      
      // 水平に配置（回転を修正）- 注意: これが駒の向きの修正
      // 回転をリセット
      piece.rotation.x = 0;
      piece.position.set(boardX, 0.035, boardZ); // Y位置を0.035に設定
      
      // 影を落とす・受ける設定を追加
      piece.castShadow = true;
      piece.receiveShadow = true;
      
      board.add(piece);
      pieces.push({ mesh: piece, x: x, z: z, player: player });
      
      return piece;
    }
    
    // 円柱のエッジを滑らかにする関数
    function bevelCylinderEdges(vertices, radius, height, edgeRadius) {
      // このバージョンのThree.jsでは直接ジオメトリの頂点をいじる代わりに
      // BufferGeometryを使って新しく作り直す方が良いですが、
      // 簡易的な実装として空関数を返しておきます
      return vertices;
    }
    
    function updatePieces() {
      // 既存の駒を削除
      for (const piece of pieces) {
        board.remove(piece.mesh);
      }
      pieces = [];
      
      // 盤面状態に基づいて駒を再作成
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (boardState[i][j] !== 0) {
            createPiece(j, i, boardState[i][j]);
          }
        }
      }
    }

    // -------------------------------
    // 有効手判定
    // -------------------------------
    function isValidMove(row, col, player) {
      if (boardState[row][col] !== 0) return false;
      
      const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [ 0, -1],          [ 0, 1],
        [ 1, -1], [ 1, 0], [ 1, 1]
      ];
      
      for (const [dx, dy] of directions) {
        let x = row + dx, y = col + dy;
        let foundOpponent = false;
        
        while (x >= 0 && x < 8 && y >= 0 && y < 8 && boardState[x][y] === -player) {
          x += dx;
          y += dy;
          foundOpponent = true;
        }
        
        if (foundOpponent && x >= 0 && x < 8 && y >= 0 && y < 8 && boardState[x][y] === player) {
          return true;
        }
      }
      
      return false;
    }

    // -------------------------------
    // 駒配置と挟んだ駒反転（パーティクル効果付き）
    // -------------------------------
    function placePiece(row, col, player, startPosition) {
      boardState[row][col] = player;
          
      const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [ 0, -1],          [ 0, 1],
        [ 1, -1], [ 1, 0], [ 1, 1]
      ];
          
      let flippedPieces = [];
          
      for (const [dx, dy] of directions) {
        let flips = [];
        let x = row + dx, y = col + dy;
            
        while (x >= 0 && x < 8 && y >= 0 && y < 8 && boardState[x][y] === -player) {
          flips.push([x, y]);
          x += dx;
          y += dy;
        }
            
        if (flips.length > 0 && x >= 0 && x < 8 && y >= 0 && y < 8 && boardState[x][y] === player) {
          for (const [fx, fy] of flips) {
            boardState[fx][fy] = player;
            flippedPieces.push([fx, fy]);
          }
        }
      }
          
      moveCount++;
      updateStatus();
      
      // 新しい駒のアニメーションを開始（ひっくり返す駒の情報も渡す）
      startPieceDropAnimation(row, col, player, startPosition, flippedPieces);
          
      // 相手のターンになったら有効手マーカーをクリア
      clearValidMoveMarkers();

      // ターンを相手に交代
      currentPlayer = -player;

      // ひっくり返すアニメーションは駒が置かれた後に実行されるため、ここでは設定だけ
      // 実際のアニメーション開始はupdateDroppingPieces内で駒の設置完了後に行われる
    }

    // 駒をひっくり返すアニメーションを開始する関数
    function startFlipAnimation(row, col, player) {
      // 既存の駒があれば探す
      let existingPiece = null;
      for (let i = 0; i < pieces.length; i++) {
        if (pieces[i].x === col && pieces[i].z === row) {
          existingPiece = pieces[i].mesh;
          break;
        }
      }

      // 既存の駒がなければ新しく作る
      if (!existingPiece) {
        return;
      }

      // 影の設定を確認
      if (!existingPiece.castShadow) {
        existingPiece.castShadow = true;
        existingPiece.receiveShadow = true;
      }

      // アニメーション情報を設定
      flippingPieces.push({
        mesh: existingPiece,
        player: player,
        originalY: 0.035, // 元のY位置を0.035に設定
        targetY: 0.032,   // 目標のY位置を0.032に設定
        frame: 0, // アニメーションフレーム
        row: row,
        col: col,
        completed: false, // アニメーション完了フラグ
        soundPlayed: false // 効果音フラグ（1回だけ再生するため）
      });
    }

    // 駒のフリップアニメーションを更新する関数
    function updateFlippingPieces(deltaTime) {
      if (flippingPieces.length === 0) return;

      // デルタタイムに乗数を適用してアニメーション速度を調整
      const adjustedDelta = deltaTime * DELTA_MULTIPLIER;

      for (let i = flippingPieces.length - 1; i >= 0; i--) {
        const piece = flippingPieces[i];
        
        // フレームを進める
        piece.frame += adjustedDelta;
        
        if (piece.frame <= FLIP_RISE_TIME) {
          // 上昇フェーズ
          const progress = piece.frame / FLIP_RISE_TIME;
          const easeProgress = easeOutQuint(progress); // より自然な上昇カーブ
          piece.mesh.position.y = piece.originalY + (FLIP_RISE_HEIGHT * easeProgress);
          
          // 上昇中に少し回転を始める（より自然な動き）
          if (progress > 0.3) {
            const preRotationProgress = (progress - 0.3) / 0.7;
            piece.mesh.rotation.x = Math.PI * 0.2 * preRotationProgress;
          }
        } 
        else if (piece.frame <= FLIP_RISE_TIME + FLIP_ROTATE_TIME) {
          // 回転フェーズ
          const progress = (piece.frame - FLIP_RISE_TIME) / FLIP_ROTATE_TIME;
          const easeProgress = easeInOutSine(progress); // よりスムーズな回転カーブ
          
          // X軸回転（180度）- よりスムーズに
          piece.mesh.rotation.x = Math.PI * (0.2 + easeProgress * 0.8);
          
          // 回転中は高さを維持し、回転の進行に合わせて徐々に下がる
          const heightFactor = 1.0 - Math.pow(progress, 2) * 0.3;
          piece.mesh.position.y = piece.originalY + FLIP_RISE_HEIGHT * heightFactor;
          
          // 回転の途中で材質を変更
          if (progress >= 0.4 && progress <= 0.6 && !piece.materialChanging) {
            piece.materialChanging = true;
            
            // 材質変更を滑らかにするため、一時的に透明度を下げる
            piece.mesh.material.transparent = true;
            piece.mesh.material.opacity = 0.6;
            
            // 少し遅れて色を変更
            setTimeout(() => {
              if (!piece.mesh) return; // 既に削除されている場合は何もしない
              
              // 材質を反対の色に変更
              piece.mesh.material = piece.player === 1 ?
                new THREE.MeshPhysicalMaterial({
                  color: 0x111111,
                  metalness: 0.15,  // 0.1から0.15に変更
                  roughness: 0.15,  // 0.2から0.15に変更でより艶やかに
                  reflectivity: 0.6, // 0.5から0.6に変更
                  clearcoat: 0.4,    // 0.3から0.4に変更
                  clearcoatRoughness: 0.15 // 0.2から0.15に変更
                }) :
                new THREE.MeshPhysicalMaterial({
                  color: 0xf5f5f5,  // より純白に
                  metalness: 0.12,  // 0.1から0.12に変更
                  roughness: 0.25,  // 0.3から0.25に変更
                  reflectivity: 0.8, // 0.7から0.8に変更
                  clearcoat: 0.6,    // 0.5から0.6に変更
                  clearcoatRoughness: 0.08 // 0.1から0.08に変更
                });
              
              // 影の設定を維持
              piece.mesh.castShadow = true;
              piece.mesh.receiveShadow = true;
              
              // 透明度を徐々に戻す
              setTimeout(() => {
                if (!piece.mesh || !piece.mesh.material) return;
                piece.mesh.material.opacity = 0.8;
                
                setTimeout(() => {
                  if (!piece.mesh || !piece.mesh.material) return;
                  piece.mesh.material.opacity = 1.0;
                  piece.mesh.material.transparent = false;
                  piece.materialChanged = true;
                }, 50);
              }, 50);
            }, 50);
          }
        } 
        else if (piece.frame <= FLIP_DURATION) {
          // 下降フェーズ
          const progress = (piece.frame - FLIP_RISE_TIME - FLIP_ROTATE_TIME) / FLIP_FALL_TIME;
          const easeProgress = easeInQuint(progress); // より自然な下降カーブ
          const targetY = piece.targetY; // 目標の高さ（0.032）
          
          // 現在の高さから目標の高さへ
          const currentHeight = piece.mesh.position.y;
          piece.mesh.position.y = currentHeight - (currentHeight - targetY) * easeProgress;
          
          // 回転が完了していることを確認
          piece.mesh.rotation.x = Math.PI;
          
          // 下降フェーズの終わり頃（90%以上）で効果音を再生
          if (progress > 0.9 && !piece.soundPlayed) {
            playSound('flip');
            piece.soundPlayed = true;
          }
        } 
        else {
          // アニメーション完了
          piece.mesh.position.y = piece.originalY;
          piece.mesh.rotation.x = 0; // 回転をリセット (0度または180度)
          piece.completed = true;
          
          // アニメーション完了した駒をリストから削除
          flippingPieces.splice(i, 1);
          
          // 全ての駒のアニメーション完了を確認
          if (flippingPieces.length === 0) {
            // 全てのアニメーションが完了したら次のターンへ
            checkGameStateAndProceed();
          }
        }
      }
    }
    
    // 追加のイージング関数（より洗練された動きのため）
    function easeOutQuint(t) {
      return 1 - Math.pow(1 - t, 5);
    }
    
    function easeInQuint(t) {
      return t * t * t * t * t;
    }
    
    function easeInOutSine(t) {
      return -(Math.cos(Math.PI * t) - 1) / 2;
    }
    
    // 元のイージング関数も保持（他の箇所で使用されている可能性あり）
    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }
    
    function easeInCubic(t) {
      return t * t * t;
    }
    
    function easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    // アニメーションが終わった後、ゲーム状態をチェックして次に進む
    function checkGameStateAndProceed() {
      // 処理中フラグをリセット
      isProcessingMove = false;
      
      // すでにゲームが終了していたら何もしない
      if (!gameStarted) return;
      
      // ゲーム終了判定とパス判定
      const gameIsOver = !hasValidMoves(currentPlayer) && !hasValidMoves(-currentPlayer);
      const playerNeedsToPass = !hasValidMoves(currentPlayer) && hasValidMoves(-currentPlayer);
      
      if (gameIsOver) {
        // 両者とも打てない場合は終了
        clearValidMoveMarkers(); // マーカーをクリア
        
        let blackCount = 0, whiteCount = 0;
        
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (boardState[i][j] === 1) blackCount++;
            else if (boardState[i][j] === -1) whiteCount++;
          }
        }
        
        const isWin = blackCount > whiteCount;
        const isDraw = blackCount === whiteCount;
        
        if (isWin) {
          updateGameMessage(`あなたの勝ち！ (${blackCount}-${whiteCount})`);
          playerWins++;
          
          // 勝利時の花火演出
          createFireworks();
        } else if (isDraw) {
          updateGameMessage(`引き分け (${blackCount}-${whiteCount})`);
          draws++;
        } else {
          updateGameMessage(`あなたの負け (${blackCount}-${whiteCount})`);
          cpuWins++;
          
          // 負け効果音
          playSound('lose');
        }
        
        updateStatus();
        // gameStarted = false; // この行を削除し、showGameResultMenu内で設定する
        
        // ゲーム結果メニュー表示
        setTimeout(() => {
          showGameResultMenu(isWin);
        }, 2000);
        
        return; // ゲーム終了時は早期リターン
      }
      
      // 現在のプレイヤーが打てない場合はパス
      if (playerNeedsToPass) {
        if (currentPlayer === 1) {
          // プレイヤーがパス
          clearValidMoveMarkers(); // マーカーをクリア
          updateGameMessage('プレイヤーはパスです。CPUの番です。');
        } else {
          // CPUがパス
          updateGameMessage('CPUはパスです。プレイヤーの番です。');
        }
        
        // 相手のターンに
        currentPlayer = -currentPlayer;
      }
      
      // 次のターンの準備
      if (gameStarted) {
        if (currentPlayer === 1) {
          // プレイヤーのターン
          isPlayerTurn = true;
          showValidMoves(1);
          if (!playerNeedsToPass) {
            updateGameMessage('プレイヤー（黒）の番です');
          }
        } else {
          // CPUのターン
          isPlayerTurn = false;
          if (!playerNeedsToPass) {
            updateGameMessage('CPU（白）の番です');
          }
          setTimeout(makeCPUMove, 100);
        }
      }
    }
    
    // -------------------------------
    // 有効手の有無とゲーム状態チェック
    // -------------------------------
    function hasValidMoves(player) {
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (isValidMove(i, j, player)) return true;
        }
      }
      
      return false;
    }
    
    // ゲーム結果メニュー表示
    function showGameResultMenu(isWin) {
      gameResultMenu = createGameResultMenu(isWin);
      // 盤面の右側に表示する（ステータスボードと被らない位置）
      gameResultMenu.position.set(0.7, 1.0, -0.9); // Z座標を-1.1から-0.9に変更（より手前に）
      gameResultMenu.rotation.y = -Math.PI / 6; // 少し内側に向ける
      scene.add(gameResultMenu);
      
      // ゲーム状態を変更せず、盤面を維持したまま再プレイのオプションを表示
      gameStarted = false;
    }

    // -------------------------------
    // CPUの手（難易度別AI）
    // -------------------------------
    function makeCPUMove() {
      if (!isPlayerTurn && !isProcessingMove) {
        // 処理中フラグをオン
        isProcessingMove = true;
        
        const validMoves = [];
        
        // 全有効手をリストアップ
        for (let i = 0; i < 8; i++) {
          for (let j =0; j < 8; j++) {
            if (isValidMove(i, j, -1)) {
              // 難易度に応じたスコアリング
              let score = 0;
              
              if (difficultyLevel === 'easy') {
                // 初級：ランダムに近い動き
                score = Math.random() * 10;
              } else if (difficultyLevel === 'medium' || difficultyLevel === 'hard') {
                // 中級以上：位置評価を含む
                
                // 角は非常に価値が高い
                if ((i === 0 || i === 7) && (j === 0 || j === 7)) {
                  score += 100;
                }
                
                // 角の隣は危険なので避ける（上級のみ）
                if (difficultyLevel === 'hard') {
                  if ((i === 0 || i === 1 || i === 6 || i === 7) && 
                      (j === 0 || j === 1 || j === 6 || j === 7) &&
                      !((i === 0 || i === 7) && (j === 0 || j === 7))) {
                    score -= 50;
                  }
                }
                
                // 端は比較的安定
                if (i === 0 || i === 7 || j === 0 || j === 7) {
                  score += 20;
                }
                
                // ひっくり返せる駒の数も考慮（上級はより重視）
                const flipCount = countFlips(i, j, -1);
                score += difficultyLevel === 'hard' ? flipCount * 2 : flipCount;
                
                // 上級は少しランダム性を減らす
                if (difficultyLevel === 'hard') {
                  score += Math.random() * 5;
                } else {
                  score += Math.random() * 15;
                }
              }
              
              validMoves.push({ row: i, col: j, score: score });
            }
          }
        }
        
        if (validMoves.length > 0) {
          // CPUの思考エフェクト
          updateGameMessage('CPUが考え中...');
          
          // スコアでソート（高い順）
          validMoves.sort((a, b) => b.score - a.score);
          
          // 難易度に応じた手の選択
          let selectedMove;
          
          if (difficultyLevel === 'easy') {
            const randomIndex = Math.floor(Math.random() * validMoves.length);
            selectedMove = validMoves[randomIndex];
          } else if (difficultyLevel === 'medium') {
            const topMoves = validMoves.slice(0, Math.min(3, validMoves.length));
            const randomIndex = Math.floor(Math.random() * topMoves.length);
            selectedMove = topMoves[randomIndex];
          } else {
            selectedMove = validMoves[0];
          }
          
          const { row, col } = selectedMove;
          
          // 思考エフェクト後に駒を置く（難易度に応じて時間差）
          const thinkTime = difficultyLevel === 'easy' ? 
                          100 + Math.random() * 100 :
                          difficultyLevel === 'medium' ? 
                          200 + Math.random() * 100 :
                          300 + Math.random() * 200;
          
          setTimeout(() => {
            // 駒を置く（アニメーション付き）
            placePiece(row, col, -1, null);
            updateGameMessage(`CPUが (${col+1}, ${row+1}) に置きました。`);
          }, thinkTime);
        } else {
          // 有効な手がない場合はパス処理
          updateGameMessage('CPUはパスです。プレイヤーの番です。');
          currentPlayer = 1;
          isPlayerTurn = true;
          isProcessingMove = false; // 処理完了
          setTimeout(() => {
            showValidMoves(1);
          }, 300);
        }
      }
    }
    
    // ひっくり返せる駒の数を数える（AIの評価用）
    function countFlips(row, col, player) {
      let count = 0;
      
      const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [ 0, -1],          [ 0, 1],
        [ 1, -1], [ 1, 0], [ 1, 1]
      ];
      
      for (const [dx, dy] of directions) {
        let flips = 0;
        let x = row + dx, y = col + dy;
        
        while (x >= 0 && x < 8 && y >= 0 && y < 8 && boardState[x][y] === -player) {
          flips++;
          x += dx;
          y += dy;
        }
        
        if (flips > 0 && x >= 0 && x < 8 && y >= 0 && y < 8 && boardState[x][y] === player) {
          count += flips;
        }
      }
      
      return count;
    }

    // -------------------------------
    // コントローラー select イベント
    // -------------------------------
    function onSelect(event) {
      if (isGripping[0] || isGripping[1]) return;
      
      // 連続した素早いトリガー操作を防止する（デバウンス処理）
      const currentTime = Date.now();
      const cooldownTime = 500; // 500ミリ秒のクールダウン期間
      
      if (currentTime - lastSelectTime < cooldownTime || isProcessingMove) {
        console.log('操作が早すぎます。少し待ってください。');
        return; // クールダウン中は処理をスキップ
      }
      
      lastSelectTime = currentTime;
      
      const controllerIndex = controllers.indexOf(event.target);
      const controller = controllers[controllerIndex];
      const raycaster = new THREE.Raycaster();
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      
      // 難易度選択メニューの処理
      if (difficultyMenu) {
        const menuIntersects = raycaster.intersectObject(difficultyMenu, true);
        
        if (menuIntersects.length > 0) {
          const intersectedObject = getParentWithUserData(menuIntersects[0].object);
          
          if (intersectedObject && intersectedObject.userData) {
            if (intersectedObject.userData.type === 'difficultyButton') {
              // 難易度ボタン選択
              highlightButton(intersectedObject);
            } else if (intersectedObject.userData.type === 'startButton') {
              // スタートボタン押下
              playSound('select');
              initBoard();
              initializeGame();
            }
          }
          return;
        }
      }
      
      // ゲーム結果メニューの処理
      if (gameResultMenu) {
        const resultIntersects = raycaster.intersectObject(gameResultMenu, true);
        
        if (resultIntersects.length > 0) {
          const intersectedObject = getParentWithUserData(resultIntersects[0].object);
          
          if (intersectedObject && intersectedObject.userData) {
            if (intersectedObject.userData.type === 'difficultyMenuButton') {
              // 難易度選択に戻るボタン
              playSound('select');
              scene.remove(gameResultMenu);
              gameResultMenu = null;
              
              // 難易度選択メニューを表示
              difficultyMenu = createDifficultyMenu();
              difficultyMenu.position.set(0, 1.3, -1.1); // -1.3から-1.1に変更（より手前に）
              difficultyMenu.userData.faceCamera = true; // カメラの方向を常に向くように
              scene.add(difficultyMenu);
            } else if (intersectedObject.userData.type === 'rematchButton') {
              // 同じ難易度で再戦
              playSound('select');
              scene.remove(gameResultMenu);
              gameResultMenu = null;
              
              // 新しいゲーム開始（盤面はリセットする）
              initBoard();
              initializeGame();
            }
          }
          return;
        }
      }
      
      // ゲームプレイの処理（ボード上での選択）
      if (board && boardBase && gameStarted && isPlayerTurn && !isProcessingMove) {
        const intersects = raycaster.intersectObject(boardBase);
        
        if (intersects.length > 0) {
          const intersect = intersects[0];
          const localPoint = board.worldToLocal(intersect.point.clone());
          
          let col = Math.floor((localPoint.x + 0.25) / 0.0625);
          let row = Math.floor((localPoint.z + 0.25) / 0.0625);
          
          if (col >= 0 && col < 8 && row >= 0 && row < 8) {
            if (isValidMove(row, col, 1)) {
              console.log('==== 駒を置く処理開始 ====');
              
              // 処理中フラグをオン
              isProcessingMove = true;
              
              // プレイヤーターンを一時的に無効化（駒のアニメーション中に再度置けないようにする）
              isPlayerTurn = false;
              
              // 駒を置く
              placePiece(row, col, 1, controller); // コントローラーオブジェクト自体を渡す
              updateGameMessage(`プレイヤーが (${col+1}, ${row+1}) に置きました。\nCPUの番です。`);
              
              // すべてのアニメーションが完了したらisProcessingMoveフラグは
              // checkGameStateAndProceed関数内でリセットされる
            } else {
              updateGameMessage('そこには置けません。別の場所を選んでください。');
            }
          }
        }
      }
    }
    
    // ユーザーデータを持つ親オブジェクトを取得
    function getParentWithUserData(object) {
      let current = object;
      
      while (current) {
        if (current.userData && 
            (current.userData.type === 'difficultyButton' || 
             current.userData.type === 'startButton' ||
             current.userData.type === 'difficultyMenuButton' ||
             current.userData.type === 'rematchButton')) {
          return current;
        }
        current = current.parent;
      }
      
      return null;
    }

    // -------------------------------
    // レンダリングループ
    // -------------------------------
    function renderFrame(time, frame) {
      if (!frame) return;
      
      const deltaTime = 1;
      
      // ステータス表示のアニメーション更新
      updateStatusDisplay(deltaTime);
      
      // 有効手マーカーのアニメーション更新
      updateValidMoveMarkers(deltaTime);
      
      // 駒のフリップアニメーションを更新
      updateFlippingPieces(deltaTime);
      
      // 駒を落とすアニメーションを更新
      updateDroppingPieces(deltaTime);
      
      // フェードインアニメーションの更新
      if (difficultyMenu && difficultyMenu.userData && difficultyMenu.userData.fadeIn) {
        const fadeProgress = difficultyMenu.userData.fadeProgress;
        const fadeSpeed = difficultyMenu.userData.fadeSpeed;
        
        if (fadeProgress < 1) {
          // フェードイン進行中
          difficultyMenu.userData.fadeProgress = Math.min(fadeProgress + fadeSpeed, 1);
          const opacity = easeOutCubic(difficultyMenu.userData.fadeProgress);
          
          // メニューの全要素の透明度を更新
          difficultyMenu.traverse(child => {
            if (child.material && child.material.transparent) {
              if (child.material.opacity !== undefined) {
                // コンポーネントタイプに基づいて目標の不透明度を設定
                let targetOpacity = 0.9; // デフォルト
                
                if (child.userData && child.userData.type === 'startButton') {
                  targetOpacity = 0.9;
                } else if (child === difficultyMenu.children[1]) { // フレーム
                  targetOpacity = 0.8;
                }
                
                child.material.opacity = opacity * targetOpacity;
              }
            }
          });
        }
      }
      
      // 盤面のフェードインアニメーション更新
      if (board && board.userData && board.userData.fadeIn) {
        const fadeProgress = board.userData.fadeProgress;
        const fadeSpeed = board.userData.fadeSpeed;
        const userData = board.userData;
        
        if (fadeProgress < 1) {
          // フェードイン進行中
          board.userData.fadeProgress = Math.min(fadeProgress + fadeSpeed, 1);
          const progress = easeOutCubic(board.userData.fadeProgress);
          
          // 透明度の更新
          board.traverse(child => {
            if (child.material && child.material.transparent) {
              if (child.material.opacity !== undefined) {
                child.material.opacity = progress;
              }
            }
          });
          
          // 位置の更新（上から降りてくる）
          const currentY = userData.initialY + (userData.targetY - userData.initialY) * progress;
          board.position.y = currentY;
          
          // 回転アニメーション
          userData.rotationProgress += fadeSpeed * 2;
          const rotationAmount = (1 - progress) * Math.PI * 0.1; // 最大10度まで傾く
          board.rotation.x = Math.sin(userData.rotationProgress) * rotationAmount;
          
          // 光るエフェクト
          userData.glowIntensity += 0.05 * userData.glowDirection;
          if (userData.glowIntensity >= 1) {
            userData.glowDirection = -1;
          } else if (userData.glowIntensity <= 0) {
            userData.glowDirection = 1;
          }
          
          // 光るエフェクトの適用
          board.traverse(child => {
            if (child.material) {
              if (child.material.emissive) {
                const baseColor = child.material.color;
                child.material.emissive.setRGB(
                  baseColor.r * userData.glowIntensity * 0.3,
                  baseColor.g * userData.glowIntensity * 0.3,
                  baseColor.b * userData.glowIntensity * 0.3
                );
              }
            }
          });
        } else {
          // アニメーション完了時の処理
          board.rotation.x = 0; // 回転をリセット
          board.position.y = userData.targetY; // 位置を確実に目標位置に
          
          // 光るエフェクトをリセット
          board.traverse(child => {
            if (child.material && child.material.emissive) {
              child.material.emissive.setRGB(0, 0, 0);
            }
          });
          
          board.userData.fadeIn = false;
        }
      }
      
      // パーティクルシステムの更新
      updateParticles(deltaTime);
      
      // グリップ中のボード移動処理
      if ((isGripping[0] || isGripping[1]) && board) {
        const currentControllerPos = new THREE.Vector3();
        const activeController = isGripping[0] ? controllers[0] : controllers[1];
        activeController.getWorldPosition(currentControllerPos);
        const controllerIndex = isGripping[0] ? 0 : 1;
        const delta = new THREE.Vector3().subVectors(currentControllerPos, controllerInitialPositions[controllerIndex]);
        board.position.copy(new THREE.Vector3().addVectors(boardInitialPosition, delta));
      } else if (board && boardBase && gameStarted && isPlayerTurn) {
        // 両方のコントローラーでカーソルを更新
        let cursorVisible = false;
        controllers.forEach((controller, index) => {
          if (!controller) return;
          
          // カーソル更新：盤のベースメッシュを対象にレイキャスト
          const raycaster = new THREE.Raycaster();
          const tempMatrix = new THREE.Matrix4();
          tempMatrix.extractRotation(controller.matrixWorld);
          raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
          raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
          
          const intersects = raycaster.intersectObject(boardBase);
          
          if (intersects.length > 0) {
            const intersect = intersects[0];
            const localPoint = board.worldToLocal(intersect.point.clone());
            
            let col = Math.floor((localPoint.x + 0.25) / 0.0625);
            let row = Math.floor((localPoint.z + 0.25) / 0.0625);
            
            if (col >= 0 && col < 8 && row >= 0 && row < 8) {
              const cellCenterX = -0.25 + 0.03125 + (col * 0.0625);
              const cellCenterZ = -0.25 + 0.03125 + (row * 0.0625);
              
              // カーソル表示を更新
              if (boardCursor) {
                boardCursor.visible = true;
                cursorVisible = true;
                boardCursor.position.set(cellCenterX, 0.032, cellCenterZ);
                
                // カーソル色：有効なら緑、無効なら赤
                const isValid = isValidMove(row, col, 1);
                const cursorColor = isValid ? 0x00ff00 : 0xff0000;
                
                boardCursor.traverse(child => {
                  if (child instanceof THREE.Mesh && child.material.color) {
                    child.material.color.setHex(cursorColor);
                  } else if (child instanceof THREE.LineSegments && child.material.color) {
                    child.material.color.setHex(cursorColor);
                  } else if (child instanceof THREE.Points && child.material.color) {
                    child.material.color.setHex(cursorColor);
                  }
                });
              }
            }
          }
        });

        // どのコントローラーも盤面を指していない場合はカーソルを非表示
        if (!cursorVisible && boardCursor) {
          boardCursor.visible = false;
        }
      } else {
        // プレイヤーターンでないときはカーソルを非表示
        if (boardCursor) {
          boardCursor.visible = false;
        }
      }
      
      // パーティクルとエフェクトの更新
      updateParticles(deltaTime);
      
      // 茶碗の湯気を更新
      if (board) {
        board.traverse((child) => {
          if (child instanceof THREE.Points && child.parent && child.parent.userData && 
              child.userData && child.userData.velocities) {
            updateSteam(child);
          }
        });
      }
      
      // お出迎えパーティクルの更新
      updateWelcomeParticles(deltaTime);
      
      // 難易度選択メニューの更新（マウスオーバー効果など）
      if (difficultyMenu) {
        // メニューを常にプレイヤーの方に向ける
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        const menuPos = new THREE.Vector3();
        difficultyMenu.getWorldPosition(menuPos);
        
        const direction = new THREE.Vector3().subVectors(cameraPos, menuPos);
        direction.y = 0; // Y軸は固定（上下を向かない）
        
        if (direction.length() > 0.001) {
          difficultyMenu.lookAt(cameraPos.x, menuPos.y, cameraPos.z);
        }
      }
      
      // ゲーム結果メニューの更新
      if (gameResultMenu) {
        // メニューを常にプレイヤーの方に向ける
        const cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        
        const menuPos = new THREE.Vector3();
        gameResultMenu.getWorldPosition(menuPos);
        
        const direction = new THREE.Vector3().subVectors(cameraPos, menuPos);
        direction.y = 0; // Y軸は固定（上下を向かない）
        
        if (direction.length() > 0.001) {
          gameResultMenu.lookAt(cameraPos.x, menuPos.y, cameraPos.z);
        }
      }
      
      renderer.render(scene, camera);
    }

    // 茶碗の湯気を更新
    function updateSteam(steam) {
      const positions = steam.geometry.attributes.position.array;
      const velocities = steam.userData.velocities;
      const lifetimes = steam.userData.lifetime;
      const maxLifetime = steam.userData.maxLifetime;
      
      for (let i = 0; i < positions.length / 3; i++) {
        const i3 = i * 3;
        
        // ライフタイム更新
        lifetimes[i]++;
        if (lifetimes[i] >= maxLifetime) {
          // リセット
          positions[i3] = (Math.random() - 0.5) * 0.015;
          positions[i3 + 1] = 0.01;
          positions[i3 + 2] = (Math.random() - 0.5) * 0.015;
          lifetimes[i] = 0;
          
          // 速度もリセット
          velocities[i] = {
            x: (Math.random() - 0.5) * 0.0005,
            y: Math.random() * 0.001 + 0.0005,
            z: (Math.random() - 0.5) * 0.0005
          };
        } else {
          // 位置を更新
          positions[i3] += velocities[i].x;
          positions[i3 + 1] += velocities[i].y;
          positions[i3 + 2] += velocities[i].z;
          
          // 湯気が薄くなる（高さに応じて）
          const height = positions[i3 + 1];
          const fadeThreshold = 0.02;
          if (height > fadeThreshold) {
            const fadeRatio = (height - fadeThreshold) / 0.02;
            steam.material.opacity = Math.max(0.7 * (1 - fadeRatio), 0);
          }
        }
      }
      
      steam.geometry.attributes.position.needsUpdate = true;
    }

    // -------------------------------
    // 初期化実行
    // -------------------------------
    init();
    initBoard();

    // メニューアニメーション更新 - レンダリングループで実行しない
    function updateDifficultyMenu(deltaTime) {
      // この関数は使用しないようにします
      return;
    }

    // 駒を置くアニメーションの定数
    const PIECE_DROP_HEIGHT = 0.1; // 駒を落とす高さ
    const PIECE_DROP_TIME = 0.6;   // 駒を落とす時間（秒）- より長く
    const PIECE_DROP_DELAY = 0.1;  // 駒を落とすまでの遅延（秒）
    const PIECE_ARC_HEIGHT = 0.15; // 放物線の高さ

    // 駒を落とすアニメーションを更新する関数
    function updateDroppingPieces(deltaTime) {
      if (droppingPieces.length === 0) return;
      
      const currentTime = Date.now();
      
      for (let i = droppingPieces.length - 1; i >= 0; i--) {
        const piece = droppingPieces[i];
        const elapsed = currentTime - piece.startTime;
        
        if (elapsed < piece.delay) continue;
        
        const progress = Math.min(1, (elapsed - piece.delay) / piece.duration);
        
        // スケールアニメーション（より小さく始まって大きくなる）
        if (progress < 0.4) {
          if (piece.isCPU) {
            // CPUの場合は少し小さく始まって大きくなる
            piece.scale = 0.8 + (0.2 * (progress / 0.4));
          } else {
            // プレイヤーの場合
            piece.scale = 0.9 + (0.1 * (progress / 0.4));
          }
        } else {
          piece.scale = 1.0;
        }
        piece.mesh.scale.set(piece.scale, piece.scale, piece.scale);
        
        // 位置のアニメーション（放物線の軌道）
        const startPos = piece.startPosition.clone();
        const targetPos = piece.targetPosition.clone();
        
        // 放物線の軌道を計算
        const arcHeight = piece.isCPU ? PIECE_ARC_HEIGHT * 0.8 : PIECE_ARC_HEIGHT; // CPUは少し低め
        
        // イージング関数を適用した進行度
        const easeInOutProgress = easeInOutCubic(progress);
        
        // 放物線効果を計算（進行度が0.5で最大高さになる）
        const verticalOffset = Math.sin(easeInOutProgress * Math.PI) * arcHeight;
        
        // 現在位置を補間
        const currentPos = new THREE.Vector3();
        currentPos.lerpVectors(startPos, targetPos, easeInOutProgress);
        
        // 放物線の高さを加える
        currentPos.y += verticalOffset;
        
        // 少しの揺れを加える（進行度に応じた微妙な横揺れ）
        if (progress > 0.1 && progress < 0.9) {
          const wobbleAmount = piece.isCPU ? 0.003 : 0.005; // CPUは少し抑えめの揺れ
          const wobbleFreq = 15; // 揺れの頻度
          const wobbleX = Math.sin(progress * wobbleFreq) * wobbleAmount;
          const wobbleZ = Math.cos(progress * wobbleFreq * 0.7) * wobbleAmount;
          currentPos.x += wobbleX;
          currentPos.z += wobbleZ;
        }
        
        // 位置を適用
        piece.mesh.position.copy(currentPos);
        
        // 駒の回転（進行中に少し回転させる）
        const maxRotation = piece.isCPU ? 0.15 : 0.2; // 最大回転角度（ラジアン）
        const rotationY = Math.sin(progress * Math.PI) * maxRotation;
        piece.mesh.rotation.y = rotationY;
        
        // アニメーション完了
        if (progress >= 1) {
          // スケールと回転を元に戻す
          piece.mesh.scale.set(1, 1, 1);
          piece.mesh.rotation.set(0, 0, 0);
          
          // 効果音を再生
          if (piece.player === 1) {
            playSound('placePlayer');
          } else {
            playSound('placeCPU');
          }
          
          // パーティクル効果
          createPlacementEffect(piece.col, piece.row);
          
          // アニメーション完了フラグ
          piece.completed = true;
          droppingPieces.splice(i, 1);
          
          // ひっくり返すアニメーションのタイミング調整
          if (piece.flippedPieces && piece.flippedPieces.length > 0) {
            // 駒が置かれてから少し待ってからひっくり返し開始
            setTimeout(() => {
              startFlippingSequence(piece.flippedPieces, piece.player);
            }, 100); // 100ms待ってからひっくり返し開始
          } else {
            // ひっくり返す駒がない場合、すぐに次のターンへ
            checkGameStateAndProceed();
          }
        }
      }
    }

    // イーズイン・イーズアウト・キュービック関数（より自然な動き）
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // ひっくり返し処理を順番に開始する関数
    function startFlippingSequence(flippedPieces, player) {
      // ひっくり返されても持ち駒は変化しない
      // (持ち駒は盤面に置かれていない駒なので、ひっくり返しでは変わらない)
      
      flippedPieces.forEach((pos, index) => {
        const delay = index * 3; // 各駒のアニメーション開始にディレイを設定
        setTimeout(() => {
          startFlipAnimation(pos[0], pos[1], player);
        }, delay * 15); // ミリ秒に変換
      });
    }

    // 駒を置くアニメーションを開始する関数
    function startPieceDropAnimation(row, col, player, startController, flippedPieces) {
      console.log('==== 駒のアニメーション開始 ====');
      console.log('Player:', player);
      
      // 駒を作成
      const piece = createPiece(col, row, player);
      
      // 影の設定が追加されていることを確認（createPiece内ですでに設定されているはず）
      if (!piece.castShadow) {
        piece.castShadow = true;
        piece.receiveShadow = true;
      }
      
      // 目標位置を計算
      const targetX = -0.25 + 0.03125 + (col * 0.0625);
      const targetZ = -0.25 + 0.03125 + (row * 0.0625);
      
      if (player === 1 && startController) {
        // プレイヤーの場合：コントローラーの先端から駒を出す
        console.log('プレイヤーの駒: コントローラーから');
        
        // コントローラーの先端位置を取得
        const startPosition = new THREE.Vector3();
        startController.getWorldPosition(startPosition);
        
        // コントローラーのローカル空間で先端方向のベクトルを計算
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(startController.quaternion);
        direction.normalize();
        
        // コントローラー先端の少し前に設定
        startPosition.add(direction.multiplyScalar(0.1));
        
        // ワールド座標からボードのローカル座標に変換
        const startPositionInBoardSpace = board.worldToLocal(startPosition.clone());
        console.log('Start Position In Board Space:', startPositionInBoardSpace);
        
        // 駒の位置を設定
        piece.position.copy(startPositionInBoardSpace);
        
        // プレイヤーの持ち駒を減らす
        decreasePlayerPieces();
      } else {
        // CPUの場合：盤面の奥側から滑らかに移動
        console.log('CPUの駒: 奥側から');
        
        // CPUの持ち駒を減らす
        decreaseCPUPieces();
        
        // 盤面の奥側（プレイヤーから見て）から出現させる
        const cpuStartX = 0; // 盤面の中央X
        const cpuStartY = 0.08; // 少し浮かせる
        const cpuStartZ = -0.35; // 盤の奥側
        
        // ボード座標系における開始位置
        piece.position.set(cpuStartX, cpuStartY, cpuStartZ);
        
        // 少し小さく始める（成長アニメーション用）
        piece.scale.set(0.8, 0.8, 0.8);
      }
      
      // アニメーション情報を設定
      droppingPieces.push({
        mesh: piece,
        startPosition: piece.position.clone(),
        targetPosition: new THREE.Vector3(targetX, 0.035, targetZ),
        startTime: Date.now(),
        duration: PIECE_DROP_TIME * 1000,
        delay: PIECE_DROP_DELAY * 1000,
        player: player,
        scale: player === 1 ? 1.0 : 0.8, // CPUは小さく始める
        row: row,
        col: col,
        flippedPieces: flippedPieces, // ひっくり返す駒の情報を保持
        completed: false,
        // CPUかプレイヤーかの情報も保持
        isCPU: player === -1
      });
    }

    // -------------------------------
    // 持ち駒ケース関連の関数
    // -------------------------------
    
    // リッチなケースのテクスチャを作成する関数
    function createCaseTexture(baseColor, isMetallic = false) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      // 背景色
      ctx.fillStyle = baseColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (isMetallic) {
        // 金属風の光沢
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
        gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.1)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
        gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.5)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 細かい光沢のラインを追加
        for (let i = 0; i < 10; i++) {
          const lineWidth = Math.random() * 2 + 1;
          const x = Math.random() * canvas.width;
          
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x + canvas.width * 0.1, canvas.height);
          ctx.stroke();
        }
      } else {
        // 木目調テクスチャ
        for (let i = 0; i < 20; i++) {
          const y = Math.random() * canvas.height;
          const width = Math.random() * 10 + 5;
          
          ctx.strokeStyle = `rgba(60, 30, 15, ${Math.random() * 0.15 + 0.05})`;
          ctx.lineWidth = width;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.bezierCurveTo(
            canvas.width * 0.3, y + Math.random() * 20 - 10,
            canvas.width * 0.6, y + Math.random() * 20 - 10,
            canvas.width, y + Math.random() * 40 - 20
          );
          ctx.stroke();
        }
      }
      
      // エッジを強調
      ctx.strokeStyle = isMetallic ? 'rgba(255, 255, 255, 0.8)' : 'rgba(30, 15, 5, 0.5)';
      ctx.lineWidth = 8;
      ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
      
      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }
    
    // 持ち駒ケースを作成する関数
    function createPieceCase(isPlayer) {
      const caseGroup = new THREE.Group();
      
      // 盤面と一体化したトレイ部分（細長い溝型）
      const caseWidth = 0.5;  // 盤面と同じ幅
      const caseHeight = 0.02; // 薄くする
      const caseDepth = 0.08;  // 奥行きを小さく
      
      const caseGeometry = new THREE.BoxGeometry(caseWidth, caseHeight, caseDepth);
      
      // プレイヤーとCPUで共通の黒系マテリアル（盤面枠と同系色）
      const caseMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x3d2b1f, 
        roughness: 0.4,
        metalness: 0.3,
      });
      
      const caseBox = new THREE.Mesh(caseGeometry, caseMaterial);
      // 影の設定を追加
      caseBox.castShadow = true;
      caseBox.receiveShadow = true;
      caseGroup.add(caseBox);
      
      // 内側の溝（駒を置く部分）
      const grooveWidth = 0.46; // 少し狭く
      const grooveHeight = 0.005;
      const grooveDepth = 0.06;
      
      const grooveGeometry = new THREE.BoxGeometry(grooveWidth, grooveHeight, grooveDepth);
      const grooveMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a0d00,
        roughness: 0.7,
        metalness: 0.1
      });
      
      const groove = new THREE.Mesh(grooveGeometry, grooveMaterial);
      groove.position.y = 0.008; // 少し上に
      // 影の設定を追加
      groove.castShadow = true;
      groove.receiveShadow = true;
      caseGroup.add(groove);
      
      // ユーザーデータを設定（後で参照するため）
      caseGroup.userData = {
        isPlayerCase: isPlayer,
        type: 'pieceCase'
      };
      
      return caseGroup;
    }
    
    // 持ち駒を増減させる関数
    function decreasePlayerPieces() {
      if (playerRemainingPieces > 0) {
        playerRemainingPieces--;
        updatePieceCaseDisplay(true);
      }
    }
    
    function decreaseCPUPieces() {
      if (cpuRemainingPieces > 0) {
        cpuRemainingPieces--;
        updatePieceCaseDisplay(false);
      }
    }
    
    // 持ち駒ケースの表示を更新する関数
    function updatePieceCaseDisplay(isPlayer) {
      const pieceCase = isPlayer ? playerPieceCase : cpuPieceCase;
      const remainingPieces = isPlayer ? playerRemainingPieces : cpuRemainingPieces;
      const displayedPieces = isPlayer ? displayedPlayerPieces : displayedCpuPieces;
      
      // 既存の駒をクリア
      while (displayedPieces.length > 0) {
        const pieceToRemove = displayedPieces.pop();
        pieceCase.remove(pieceToRemove);
      }
      
      // 駒の表示数と間隔の設定
      const maxPieces = MAX_PIECES; // 最大32個
      const displayWidth = 0.45;    // トレイの内側幅
      
      // 32個の駒が一列に収まるように間隔を調整
      const spacing = displayWidth / (maxPieces + 1);
      
      // 左端の開始位置
      const startX = -displayWidth / 2 + spacing;
      
      // 駒を配置（プレイヤーは左から減る、CPUは右から減る）
      for (let i = 0; i < remainingPieces; i++) {
        // 盤面の駒と同じサイズで
        const radius = 0.028;  // 盤面と同じ半径
        const height = 0.004;  // 盤面と同じ高さ
        const segments = 32;   // 円周の分割数
        const radiusSegments = 32; // エッジの滑らかさのための分割数
        
        // エッジを丸くした円柱ジオメトリ
        const geometry = new THREE.CylinderGeometry(radius, radius, height, segments);
        
        // プレイヤーとCPUで異なるマテリアル（盤面と同じ）
        const material = isPlayer ?
          new THREE.MeshPhysicalMaterial({
            color: 0x111111,
            metalness: 0.15,  // 0.1から0.15に変更
            roughness: 0.15,  // 0.2から0.15に変更でより艶やかに
            reflectivity: 0.6, // 0.5から0.6に変更
            clearcoat: 0.4,    // 0.3から0.4に変更
            clearcoatRoughness: 0.15 // 0.2から0.15に変更
          }) :
          new THREE.MeshPhysicalMaterial({
            color: 0xf5f5f5,  // より純白に
            metalness: 0.12,  // 0.1から0.12に変更
            roughness: 0.25,  // 0.3から0.25に変更
            reflectivity: 0.8, // 0.7から0.8に変更
            clearcoat: 0.6,    // 0.5から0.6に変更
            clearcoatRoughness: 0.08 // 0.1から0.08に変更
          });
        
        const piece = new THREE.Mesh(geometry, material);
        // 影の設定を追加
        piece.castShadow = true;
        piece.receiveShadow = true;
        
        // 配置位置の計算
        let positionIndex;
        if (isPlayer) {
          // プレイヤーは左から減る（0が一番左、31が一番右）
          positionIndex = i;
        } else {
          // CPUは右から減る（0が一番右、31が一番左）
          positionIndex = maxPieces - remainingPieces + i;
        }
        
        // 実際の位置を計算
        const offsetX = startX + positionIndex * spacing;
        
        // Z方向は中央に配置
        const offsetZ = 0;
        
        // すべての駒を同じ高さに配置
        const offsetY = 0.013;
        
        piece.position.set(offsetX, offsetY, offsetZ);
        
        // 駒を正しく向ける（円柱の側面がプレイヤーを向くように）
        piece.rotation.z = Math.PI / 2;  // Z軸周りに90度回転
        
        pieceCase.add(piece);
        displayedPieces.push(piece);
      }
    }
    
    // 持ち駒ケースを初期化する関数
    function initPieceCases() {
      // 既存のケースがあれば削除
      if (playerPieceCase) {
        board.remove(playerPieceCase);
      }
      
      if (cpuPieceCase) {
        board.remove(cpuPieceCase);
      }
      
      // 持ち駒数をリセット
      playerRemainingPieces = MAX_PIECES;
      cpuRemainingPieces = MAX_PIECES;
      
      // プレイヤーの持ち駒トレイを作成・配置
      playerPieceCase = createPieceCase(true);
      playerPieceCase.position.set(0, 0.01, 0.3); // 盤面の手前端に接するように
      playerPieceCase.rotation.y = 0; // まっすぐ配置
      board.add(playerPieceCase);
      
      // CPUの持ち駒トレイを作成・配置
      cpuPieceCase = createPieceCase(false);
      cpuPieceCase.position.set(0, 0.01, -0.3); // 盤面の奥側端に接するように
      cpuPieceCase.rotation.y = 0; // まっすぐ配置
      board.add(cpuPieceCase);
      
      // 表示を初期化
      displayedPlayerPieces = [];
      displayedCpuPieces = [];
      
      // 持ち駒の表示を更新
      updatePieceCaseDisplay(true);
      updatePieceCaseDisplay(false);
    }

    // ページ読み込み時に初期化を呼び出し
    init();

    // 花火の音再生関数
    function playFireworkSound() {
      if (!listener || !listener.context) {
        console.warn('Audio listener not initialized');
        return;
      }
      
      // 花火音を切るタイマーを設定（10秒後に停止）
      if (window.fireworkSoundTimeout) {
        clearTimeout(window.fireworkSoundTimeout);
      }
      
      window.fireworkSoundTimeout = setTimeout(() => {
        if (window.fireworksActive) {
          // 10秒後に音を止めるが、花火は継続
          console.log('花火音を停止しますが、視覚効果は継続します');
        }
      }, 10000); // 10秒後に音を止める
    }

    // ランダムな花火の音を再生
    function playRandomFireworkSound() {
      if (!listener || !listener.context || !window.fireworksActive) return;
      
      // 花火の音が停止状態なら何もしない（10秒のタイムアウト後）
      if (!window.fireworkSoundTimeout) return;
      
      const context = listener.context;
      
      // 各種花火音のバリエーション
      const soundType = Math.floor(Math.random() * 3);
      const volume = 0.15; // 音量を控えめに
      
      // ゲインノード
      const gainNode = context.createGain();
      gainNode.connect(context.destination);
      gainNode.gain.value = volume;
      
      // ノイズ発生器（ホワイトノイズ）
      const bufferSize = context.sampleRate * 0.5; // 0.5秒分
      const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
      const data = buffer.getChannelData(0);
      
      // ノイズ生成
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      
      // ノイズソース
      const noise = context.createBufferSource();
      noise.buffer = buffer;
      
      // フィルター
      const filter = context.createBiquadFilter();
      filter.type = 'bandpass';
      
      switch (soundType) {
        case 0: // 打ち上げ音
          filter.frequency.value = 500;
          filter.Q.value = 1;
          
          // 音量エンベロープ
          gainNode.gain.setValueAtTime(0, context.currentTime);
          gainNode.gain.linearRampToValueAtTime(volume, context.currentTime + 0.05);
          gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.3);
          
          // 再生時間
          noise.start();
          noise.stop(context.currentTime + 0.3);
          break;
          
        case 1: // 爆発音（短め）
          filter.frequency.value = 800;
          filter.Q.value = 0.7;
          
          // 音量エンベロープ
          gainNode.gain.setValueAtTime(0, context.currentTime);
          gainNode.gain.linearRampToValueAtTime(volume, context.currentTime + 0.01);
          gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.2);
          
          // 再生時間
          noise.start();
          noise.stop(context.currentTime + 0.2);
          break;
          
        case 2: // 大きな爆発音
          filter.frequency.value = 300;
          filter.Q.value = 0.5;
          
          // 音量エンベロープ
          gainNode.gain.setValueAtTime(0, context.currentTime);
          gainNode.gain.linearRampToValueAtTime(volume, context.currentTime + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.5);
          
          // 再生時間
          noise.start();
          noise.stop(context.currentTime + 0.5);
          break;
      }
      
      // 接続
      noise.connect(filter);
      filter.connect(gainNode);
    }

    // ゲームの状態をリセットして、新しいゲームを開始する
    function resetAndStartNewGame() {
      if (gameResultMenu) {
        scene.remove(gameResultMenu);
        gameResultMenu = null;
      }
      
      if (confetti) {
        scene.remove(confetti);
        confetti = null;
      }
      
      // 盤面をリセット
      resetBoard();
      initializeGame();
      
      // 難易度選択メニューでは、選択した難易度に応じて盤を設置
      if (!difficultySelected) {
        difficultySelected = true;
        
        if (difficultyMenu) {
          scene.remove(difficultyMenu);
          difficultyMenu = null;
        }
        
        // 効果音
        playSound('select');
        
        // ゲーム開始
        gameStarted = true;
        currentPlayer = 1; // 黒（プレイヤー）から開始
        isPlayerTurn = true;
        
        // 有効な着手を表示
        showValidMoves(currentPlayer);
      }
    }
    
    // -------------------------------
    // デスクトップモードの開始
    // -------------------------------
    function startDesktopMode() {
      try {
        // ローディング画面を表示
        const loadingUI = document.getElementById('loadingUI');
        if (loadingUI) {
          loadingUI.style.display = 'flex';
        }
        
        // メニューUIを非表示
        document.getElementById('menuUI').style.display = 'none';
        
        // Three.jsのレンダラーを設定（XRなしの通常のレンダラー）
        renderer.xr.enabled = false;
        
        // カメラの位置を設定（デスクトップ表示用）
        camera.position.set(0, 1.5, 1.2);
        camera.lookAt(0, 0.5, 0);
        
        // 通常のアニメーションループを開始
        renderer.setAnimationLoop(renderDesktopFrame);
        
        // 音声の初期化
        initSounds();
        
        // BGMを再生するコード
        const audioLoader = new THREE.AudioLoader();
        const bgm = new THREE.Audio(listener);
        audioLoader.load('osero.mp3', function(buffer) {
          bgm.setBuffer(buffer);
          bgm.setLoop(true);
          bgm.setVolume(0.3);
          bgm.play();
        });
        
        // ローディング画面を非表示
        setTimeout(() => {
          if (loadingUI) loadingUI.style.display = 'none';
          
          // 難易度選択メニュー表示
          placeInitialEnvironment();
          
          // デスクトップモードのマウスコントロールを設定
          setupDesktopControls();
        }, 1500);
        
      } catch (error) {
        // エラー時にはローディング画面を非表示に
        const loadingUI = document.getElementById('loadingUI');
        if (loadingUI) loadingUI.style.display = 'none';
        
        console.error('デスクトップモード開始中にエラー:', error);
        alert('デスクトップモード開始中にエラーが発生しました: ' + error.message);
      }
    }

    // 環境音のフィルタとボリュームを調整
    function adjustEnvSoundVolume(filter, gainNode) {
      // フィルタとボリュームノードが存在する場合のみ処理
      if (filter && gainNode) {
        filter.connect(gainNode);
      }
    }
    
    // -------------------------------
    // デスクトップモード用マウス操作の設定
    // -------------------------------
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let isMouseDown = false;

    function setupDesktopControls() {
      const canvas = document.getElementById('canvas');
      
      // マウス移動のイベントリスナー
      canvas.addEventListener('mousemove', function(event) {
        // マウス位置を正規化 (-1 から 1 の範囲)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });
      
      // クリックのイベントリスナー
      canvas.addEventListener('mousedown', function(event) {
        isMouseDown = true;
        handleDesktopClick();
      });
      
      canvas.addEventListener('mouseup', function() {
        isMouseDown = false;
      });
      
      // ウィンドウリサイズ時の対応
      window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // -------------------------------
    // デスクトップモード用カーソル処理
    // -------------------------------
    function updateDesktopCursor() {
      // プレイヤーターンでない場合は処理しない
      if (!gameStarted || !isPlayerTurn || !board || !boardBase) return;
      
      // レイキャストで交差を確認
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(boardBase);
      
      let cursorVisible = false;
      
      if (intersects.length > 0) {
        const intersect = intersects[0];
        const localPoint = board.worldToLocal(intersect.point.clone());
        
        let col = Math.floor((localPoint.x + 0.25) / 0.0625);
        let row = Math.floor((localPoint.z + 0.25) / 0.0625);
        
        if (col >= 0 && col < 8 && row >= 0 && row < 8) {
          const cellCenterX = -0.25 + 0.03125 + (col * 0.0625);
          const cellCenterZ = -0.25 + 0.03125 + (row * 0.0625);
          
          // カーソル表示を更新
          if (boardCursor) {
            boardCursor.visible = true;
            cursorVisible = true;
            boardCursor.position.set(cellCenterX, 0.032, cellCenterZ);
            
            // カーソル色：有効なら緑、無効なら赤
            const isValid = isValidMove(row, col, 1);
            const cursorColor = isValid ? 0x00ff00 : 0xff0000;
            
            boardCursor.traverse(child => {
              if (child instanceof THREE.Mesh && child.material.color) {
                child.material.color.setHex(cursorColor);
              } else if (child instanceof THREE.LineSegments && child.material.color) {
                child.material.color.setHex(cursorColor);
              } else if (child instanceof THREE.Points && child.material.color) {
                child.material.color.setHex(cursorColor);
              }
            });
          }
        }
      }
      
      // 盤面上にカーソルがない場合は非表示
      if (!cursorVisible && boardCursor) {
        boardCursor.visible = false;
      }
    }

    // -------------------------------
    // デスクトップモード用クリック処理
    // -------------------------------
    function handleDesktopClick() {
      // プレイヤーターンでない場合は処理しない
      if (!gameStarted || !isPlayerTurn || !board || !boardBase) return;
      
      raycaster.setFromCamera(mouse, camera);
      
      // 難易度選択メニューの処理
      if (!difficultySelected && difficultyMenu) {
        // メニューの子要素を検索
        const menuIntersects = raycaster.intersectObject(difficultyMenu, true);
        
        if (menuIntersects.length > 0) {
          // クリックしたボタンを見つける
          const clickedButton = findButton(menuIntersects[0].object);
          if (clickedButton) {
            // 難易度ボタンがクリックされた場合
            if (clickedButton.userData.type === 'difficultyButton') {
              highlightButton(clickedButton);
            }
            // スタートボタンがクリックされた場合
            else if (clickedButton.userData.type === 'startButton') {
              handleStartButtonClick();
            }
          }
          return;
        }
      }
      
      // ゲーム結果メニューの処理
      if (gameResultMenu) {
        const resultIntersects = raycaster.intersectObject(gameResultMenu, true);
        
        if (resultIntersects.length > 0) {
          const clickedButton = findButton(resultIntersects[0].object);
          if (clickedButton) {
            if (clickedButton.userData.type === 'difficultyMenuButton') {
              // 難易度選択に戻るボタン
              handleDifficultyMenuButtonClick();
            } else if (clickedButton.userData.type === 'rematchButton') {
              // 同じ難易度で再戦ボタン
              handleRematchButtonClick(clickedButton.userData.playerWon);
            }
          }
          return;
        }
      }
      
      // 盤面のクリック処理
      const boardIntersects = raycaster.intersectObject(boardBase);
      
      if (boardIntersects.length > 0) {
        const intersect = boardIntersects[0];
        const localPoint = board.worldToLocal(intersect.point.clone());
        
        let col = Math.floor((localPoint.x + 0.25) / 0.0625);
        let row = Math.floor((localPoint.z + 0.25) / 0.0625);
        
        if (col >= 0 && col < 8 && row >= 0 && row < 8) {
          handlePlacePiece(row, col);
        }
      }
    }

    // -------------------------------
    // 駒を置く処理（共通処理）
    // -------------------------------
    function handlePlacePiece(row, col) {
      // ゲームが開始されていない、もしくはプレイヤーのターンでない場合は処理しない
      if (!gameStarted || !isPlayerTurn || isProcessingMove) return;
      
      // 有効な手かどうか確認
      if (isValidMove(row, col, currentPlayer)) {
        isProcessingMove = true;
        
        // 駒を置く音を再生
        playSound('placePlayer');
        
        // 実際に駒を配置
        placePiece(row, col, currentPlayer);
        
        // フリップする駒のアニメーションを開始
        const flippedPieces = getFlippablePieces(row, col, currentPlayer);
        for (const [r, c] of flippedPieces) {
          flipPiece(r, c);
        }
        
        // ターン終了時の処理をスケジュール
        setTimeout(() => {
          completePlayerTurn();
        }, 800);
      }
    }
  </script>
</body>
</html>